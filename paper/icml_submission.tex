\documentclass{article}
\usepackage{icml2025}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{tikz}
\usetikzlibrary{positioning,trees,matrix}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{assumption}[theorem]{Assumption}

\icmltitlerunning{Short Title}

\begin{document}

\twocolumn[
\icmltitle{<Full Paper Title>}

\begin{icmlauthorlist}
\icmlauthor{First A. Author}{xxx}
\icmlauthor{Second B. Author}{yyy}
\icmlauthor{Third C. Author}{zzz}
\end{icmlauthorlist}

\icmlaffiliation{xxx}{Affiliation One, City, Country}
\icmlaffiliation{yyy}{Affiliation Two, City, Country}
\icmlaffiliation{zzz}{Affiliation Three, City, Country}

\icmlcorrespondingauthor{First A. Author}{first.last@institution.edu}

\icmlkeywords{Machine Learning, ICML}
\vskip 0.3in
]

\printAffiliationsAndNotice{}

\begin{abstract}
\end{abstract}

\section{Introduction}

\section{Related Work}



\section{Preliminaries and Problem Setup}
\label{sec:prelims}

\paragraph{Reasoning structure.}
We model inference as expansion of a directed tree (or a DAG with tie-breaking) $G=(V,E)$.
Each node $v\in V$ is a \emph{reasoning step} with textual content $x_v$; the root $v_0$ holds the task statement.
Each edge $e=(u\!\rightarrow\! v)\in E$ carries a natural-language label $L_e$ and induces a control vector $\Pi_e$ used to expand the child $v$.
We distinguish two roles: a \emph{labeller} LM $\Lambda$ that proposes edge labels, and a \emph{tuner} LM $\Psi$ that emits control, with mappings
\begin{equation*}
  L=\Lambda(P,C), \qquad \Pi=\Psi(P,L,C).
\end{equation*}
Here $P$ denotes the parent node text (and any exposed metadata), and $C$ denotes a compact context.

\paragraph{Context $C$.}
We keep $C$ compact and measurable. In our setting, $C$ may include:
\begin{itemize}
  \item \textbf{Frontier uncertainty:} summaries such as the median $\sigma$ across candidate values;
  \item \textbf{Novelty:} nearest-neighbor distances among frontier candidates (embedding or lexical);
  \item \textbf{Depth:} distance from the root;
  \item \textbf{Sibling/frontier summaries:} best $(\mu,\sigma)$ among siblings;
  \item \textbf{Raw label history:} the most recent edge labels as \emph{strings} (from siblings and, optionally, a short frontier window);
  \item \textbf{Budgets:} token usage, retrieval calls, and verification outcomes.
\end{itemize}

\paragraph{Control schema $\Pi$.}
The tuner controls a task-agnostic set of fields:
\begin{itemize}
  \item \textbf{Decoding:} temperature, top-$p$, maximum tokens, repetition penalty;
  \item \textbf{Generation:} \texttt{gen\_count} $\in \mathbb{N}^{+}$ (bundle size under this label);
  \item \textbf{Search:} branch quota and an exploration coefficient $\beta$;
  \item \textbf{Retrieval:} mixture weights over indices or corpora;
  \item \textbf{Verification:} number and strictness of checks;
  \item \textbf{(Optional) Selection hint:} \texttt{keep\_k} $\in \mathbb{N}^{+}$ (if set, passed to the child-selection module).
\end{itemize}
Given $\Pi$, a downstream selector (agnostic to NLEL) can use scores such as $S=\mu+\beta\,\sigma$ or a standard ToT culling operator.

\paragraph{Edge labels.}
Labels are produced by $\Lambda$ from $(P,C)$.

\paragraph{Problem instances.}
An instance consists of a task $T$, root $v_0$ text, and an evaluation function producing $(\mu,\sigma)$ for partial answers.
Unless noted, we treat $G$ as a tree; extension to DAGs is straightforward by merging isomorphic textual states.

\paragraph{Notation summary.}
\begin{center}
\begin{tabular}{@{}ll@{}}
\toprule
Symbol & Meaning \\\midrule
$P$ & parent node content (text + exposed metadata) \\
$L$ & natural-language edge label \\
$C$ & compact context features (bulleted above) \\
$\Lambda$ & labeller LM mapping $(P,C)\!\to\!L$ \\
$\Psi$ & tuner LM mapping $(P,L,C)\!\to\!\Pi$ \\
$\Pi$ & control vector (decoding, search, retrieval, verification) \\
$\mu,\sigma$ & value / uncertainty estimates used by the selector \\
$w$ & retrieval mixture weights over indices/corpora \\
$\beta$ & exploration coefficient in selection \\
$c_e,\,C_t$ & per-edge and cumulative compute cost \\
\texttt{gen\_count} & generation bundle size (per edge label) \\
\bottomrule
\end{tabular}
\end{center}

\section{Method}
\label{sec:method}

\subsection{Overview}
We propose \emph{Natural Language Edge Labelling} (NLEL), a control layer for structured language-model (LM) reasoning in which each edge carries a natural-language label that specifies \emph{how} the next step should proceed (e.g., ``seek a counterexample'', ``work backward'', ``apply an anthropological lens; probe for defeaters''). A dedicated \emph{tuner} LM reads a tuple $(P,L,C)$---the parent node $P$, the edge label $L$, and the current context $C$---and maps it directly to a control vector $\Pi$ that configures decoding, search, retrieval, and verification for the next expansion.

\subsection{Inputs, Outputs, and Mapping}
\paragraph{Inputs.} $P$ is the current parent state (text and optional structure). $L$ is a free-form natural-language directive for the edge. $C$ denotes the remaining state, which can include the partial tree/graph, concise summaries of the frontier and siblings, budget trackers, and verifier configuration.
\paragraph{Output.} A control vector $\Pi$ whose fields actuate the reasoning stack. A task-agnostic schema can include:
\begin{itemize}
  \item \textbf{Decoding:} temperature, top-$p$, max tokens, repetition penalty;
  \item \textbf{Search:} branch quota, variance/risk coefficient $\beta$, and a UCT/exploration constant;
  \item \textbf{Retrieval:} mixture weights over indices or corpora;
  \item \textbf{Verification:} number and strictness of checks.
\end{itemize}
\paragraph{Mapping.} Let $\Psi : (P,L,C)\mapsto \Pi$ denote the tuner mapping. In our prompt-only instantiation (Section~\ref{subsec:jpe}), $\Psi$ is realized by a JSON parameter emitter that respects a schema with bounds and learns from a compact in-prompt ledger of historical expansions.

\subsection{Expansion Procedure}
We expand the structure at a parent $p$ in two phases: label emission and bundle generation, followed by a single selection step.
\begin{enumerate}
  \item \textbf{Emit labels.} Use the labeller to obtain a set of edge labels for $p$:
  $\mathcal{L}_p = \{L_1,\dots,L_m\}$, where each $L_i=\Lambda(P,C)$. The number of labels may be governed by a search quota or policy.
  \item \textbf{Generate bundles under each label.} For each $L\in\mathcal{L}_p$, obtain control $\Pi=\Psi(P,L,C)$ and generate a bundle of \texttt{gen\_count} candidate children under $L$ using $\Pi$.
  \item \textbf{Select children (ToT).} Let $\mathcal{B}(L)$ denote the bundle generated under label $L$. Form the union of all candidates for the parent, $\mathcal{C}_p=\bigcup_{L\in\mathcal{L}_p}\mathcal{B}(L)$, and apply the standard ToT child-selection operator to $\mathcal{C}_p$. We inherit ToT's selector as-is.
  \item \textbf{Update state.} Add survivors to the frontier and update $C$ (budgets, summaries, raw label history strings).
\end{enumerate}


% ---------- WIDE FIGURE WITH A LARGER TREE AND CONCRETE LABELS ----------
\begin{figure*}[!t]
  \centering
  \begin{tikzpicture}[
    node/.style={rectangle, draw, rounded corners, inner sep=2pt, align=left, font=\scriptsize, text width=4.8cm},
    % Two label variants so we can place them above/below and nudge them off the node edge.
    elabelTop/.style={pos=0.88, above, yshift=2pt, fill=white, inner sep=1pt, font=\scriptsize},
    elabelBot/.style={pos=0.88, below, yshift=-2pt, fill=white, inner sep=1pt, font=\scriptsize}
  ]
    %--- Grid with explicit rows: [1, 2, 2] ---
    \matrix[matrix of nodes, row sep=16mm, column sep=18mm] (M) {
      % Row 1 (1 node)
      \node[node] (root) {Goal: Prove that if $n$ is odd then $n^2$ is odd.}; \\
      % Row 2 (2 nodes)
      \node[node] (alg) {%
        \textbf{$\mathrm{\Pi}$ preview:} temp=0.15; retrieval=0; verify=2; max\_tokens=40; $\beta$=0.10; gen\_count=1.%
        \par\noindent\rule{\linewidth}{0.3pt}\vspace{2pt}\\%
        Algebraic step: $n=2k{+}1 \Rightarrow n^2=4k^2+4k+1$.%
      };
      &
      \node[node] (contra) {%
        \textbf{$\mathrm{\Pi}$ preview:} temp=0.20; top-$p$=0.60; retrieval=[math-lemmas:0.70, general:0.30]; verify=1; max\_tokens=40; $\beta$=0.10, gen\_count=1.%
        \par\noindent\rule{\linewidth}{0.3pt}\vspace{2pt}\\%
        Contrapositive: if $n^2$ is even then $n$ is even (parity lemma).%
      }; \\
      % Row 3 (2 nodes; both under the SAME parent 'alg')
      \node[node] (alg_reduce) {%
        \textbf{$\mathrm{\Pi}$ preview:} temp=0.12; max\_tokens=24; verify=1. gen\_count=1.%
        \par\noindent\rule{\linewidth}{0.3pt}\vspace{2pt}\\%
        Reduce: $n^2=2(2k^2+2k)+1$ (odd).%
      };
      &
      \node[node] (alg_stop) {%
        \textbf{$\mathrm{\Pi}$ preview:} temp=0.10; max\_tokens=16; stop=1. gen\_count=1.%
        \par\noindent\rule{\linewidth}{0.3pt}\vspace{2pt}\\%
        Conclude oddness; stop.%
      }; \\
    };

    %--- Edges (explicit): start at parent.south, end at child.north
    % Shorten near nodes so labels have breathing room and don't overlap the boxes
    \draw[shorten <=6pt, shorten >=8pt] (root.south)
      -- node[elabelTop]{Algebraic: no retrieval; low temp; verify twice; $\leq 40$ tokens}
      (alg.north);

    \draw[shorten <=6pt, shorten >=8pt] (root.south)
      -- node[elabelTop]{Contrapositive: cite parity lemma; low temp}
      (contra.north);

    \draw[shorten <=6pt, shorten >=8pt] (alg.south)
      -- node[elabelTop]{Reduce to $2m{+}1$ form; one equation}
      (alg_reduce.north);

    \draw[shorten <=6pt, shorten >=8pt] (alg.south)
      -- node[elabelTop]{Stop with canonical form}
      (alg_stop.north);
  \end{tikzpicture}
  \caption{A synthetic example of NLEL being used in a ToT setting. For simplicity, gen\_count is set to one for all $\Pi_i$.}
  \label{fig:nlel_schematic}
\end{figure*}
 -----------------------------------------------------------------------

\subsection{Prompt-Only JSON Parameter Emitter (JPE)}
\label{subsec:jpe}
The tuner LM receives three ingredients in the prompt: (i) a concise \emph{schema} that specifies control fields and bounds; (ii) a \emph{historical ledger} of $(P_i,L_i,C_i)\!\mapsto\!\Pi_i$ with outcomes, where rows are tagged as \emph{Pareto} or \emph{dominated} to provide contrastive signals about efficient trade-offs; and (iii) the \emph{current case} $(P,L,C)$. It emits a single JSON object $\Pi$ that must validate against the schema. The ledger can be curated with a lightweight objective that balances task success against compute usage and verification reliability (e.g., success@compute with penalties for excessive tokens or failed checks).

\subsection{Context Features}
To keep $C$ compact and measurable, we surface a small set of features that capture the state of search:
\begin{itemize}
  \item \textbf{Frontier uncertainty:} median $\sigma$ across candidate downstream values (from ensembles, bootstraps, or dropout estimates);
  \item \textbf{Novelty deficit:} median nearest-neighbor distance among frontier candidates (embedding or lexical);
  \item \textbf{Depth:} distance from root (enables exploration annealing and quota schedules);
  \item \textbf{Sibling/frontier summaries:} best $(\mu,\sigma)$ among siblings; raw label history (strings); budget usage.
\end{itemize}

\subsection{Downstream Selection (Agnostic to NLEL)}
We inherit the standard ToT child-selection operator and apply it once to the union of all candidates produced for a parent (across labels).
\subsection{Stability and Safety}
We employ non-intrusive guards: (i) strict schema/bounds validation for emitted JSON; (ii) projection into a trust region around safe defaults to prevent pathological jumps; and (iii) depth-annealed exploration so late-depth expansions remain conservative.

\subsection{Design Notes}
NLEL is compatible with a non-reasoning tuner or a reasoning tuner (e.g., CoT/ToT) used \emph{only} as a controller. The child reasoner can be held fixed to cleanly attribute outcomes to the edge label and the control vector~$\Pi$.

\section{Theory (Optional)}

\section{Experiments}
% TODO: Empirical check for depth annealing (Section 3.7(iii)):
%       Compare depth-annealed exploration vs. no annealing under identical budgets.
%       Measure success@compute and reliability under verification constraints.
% TODO: Ablations on: (a) label vocabularies, (b) tuner type, (c) ledger size.

\section{Limitations}

\section{Conclusion}

\section*{Impact Statement}

% \section*{Acknowledgements}

\bibliographystyle{icml2025}
\bibliography{references}

\appendix

\section{Additional Experimental Details}
\section{Proofs}
\section{Extra Results}

\end{document}
